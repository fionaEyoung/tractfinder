#!/usr/bin/env python3

# Copyright (c) 2008-2023 the MRtrix3 contributors.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Covered Software is provided under this License on an "as is"
# basis, without warranty of any kind, either expressed, implied, or
# statutory, including, without limitation, warranties that the
# Covered Software is free of defects, merchantable, fit for a
# particular purpose or non-infringing.
# See the Mozilla Public License v. 2.0 for more details.
#
# For more details, see http://www.mrtrix.org/.

# Script for mapping fibre bundles based on provided tract orientation atlas[es]
# Written by Fiona Young, 2023

import sys, os, shutil, copy

MAP_SUFFIX = '_tractmap'
DOF = 12

def usage(cmdline):
  from mrtrix3 import app

  cmdline.set_author('Fiona Young (fiona.young.15@ucl.ac.uk)')
  cmdline.set_synopsis('Map fibre bundles based on tract orientation atlas(es)')
  # cmdline.add_description('')

  cmdline.add_argument('input',help='The input FOD image')
  cmdline.add_argument('arg_pairs', metavar=['atlas output [atlas output ...]'], help='pairs of atlas / output images. If only one of each is specified and both are directories, all atlas present in the first directory will be mapped and the results will be stored in the second.', nargs='+')

  # Virtue options
  virtue_options = cmdline.add_argument_group('!!!NOT CURRENTLY IMPLEMENTED!!! Tumour deformation modelling options')
  virtue_options.add_argument('-brain_mask', metavar='image', help='Provide brain mask. If not provided, will attempt to estimate brain mask based on input FOD image (this is flakey!)')
  virtue_options.add_argument('-tumour', metavar='image', help='Provide tumour mask. This argument is required and sufficient to trigger deformation modelling')
  virtue_options.add_argument('-k', metavar='type', help='Type of deformation to model. Options are: linear, exponential (default: linear)',
                                choices=['linear', 'exponential'], default='linear')
  virtue_options.add_argument('-scale', metavar='fraction', help='Tumour scale factor (formerly squishfactor) (default: 1)')
  virtue_options.add_argument('-store_lookup', metavar='directory', help='Location for storing/reusing Dt/Db lookup matrices for deformation algorithm. Recommended for speedup if recomputing deformation.')
  virtue_options.add_argument('-template', help='Provide a template image to define the voxel grid of the output maps/segmentations. By default, the grid of the FOD input is used.')

  # General options
  common_options = cmdline.add_argument_group('General tractfinder options')
  common_options.add_argument('-transform', help='provide transformation from atlas space to subject space')
  common_options.add_argument('-struct', metavar='template subject', nargs=2, help='provide structural images in template (=atlas) and subject space for coregistration. Note: the subject image is assumed to be adequately coregistered with the diffusion space')
  common_options.add_argument('-premasked', action='store_true', help='indicate that the input structural image has been brain masked (otherwise script will perform brain extraction.) Note: the structural image in template space is ALWAYS assumed to be masked')
  common_options.add_argument('-binary', nargs='?', const=0.05,  help='threshold tractmap to binary segmentation (default value: 0.05)')
  common_options.add_argument('-suffix', nargs=1, default=MAP_SUFFIX, help=f'define a suffix to append to each output (relevant only atlas directory as input) (default: {MAP_SUFFIX}')

  # Citations
  cmdline.add_citation('Young, F., Aquilina, K., A Clark, C., & D Clayden, J. (2022). Fibre tract segmentation for intraoperative diffusion MRI in neurosurgical patients using tract-specific orientation atlas and tumour deformation modelling. International journal of computer assisted radiology and surgery, 17(9), 1559–1567. https://doi.org/10.1007/s11548-022-02617-z')
  cmdline.add_citation('Nowinski, W. L., & Belov, D. (2005). Toward atlas-assisted automatic interpretation of MRI morphological brain scans in the presence of tumor. Academic radiology, 12(8), 1049–1057. https://doi.org/10.1016/j.acra.2005.04.018')
  cmdline.add_citation('Jenkinson, M., Bannister, P., Brady, J. M. and Smith, S. M. Improved Optimisation for the Robust and Accurate Linear Registration and Motion Correction of Brain Images. NeuroImage, 17(2), 825-841, 2002.', condition='If performing registration (i.e. -linear option not provided)', is_external=True)

# "Overloaded" from mrtrix3.path.make_dir to check if existing file is a directory
# Make a directory if it doesn't exist; don't do anything if it does already exist
def make_dir(path):
  from mrtrix3 import app, MRtrixError
  import errno
  try:
    os.makedirs(path)
    app.debug('Created directory ' + path)
  except OSError as exception:
    if exception.errno != errno.EEXIST:
      raise
    elif not os.path.isdir(path):
      raise MRtrixError('Path \'' + path + '\' exists and is not a directory')
    app.debug('Directory \'' + path + '\' already exists')

# adapt behaviour of flag_mutually_exclusive_options() which is not suitable here,
# as want to check at least one provided, but not mutex. Ignore the "value is different from default"
# check here: required arguments shouldn't have defaults
def check_from_required(args_in, required_args, prog=sys.argv[0]):
  count = sum([bool(getattr(args_in, option, False)) for option in required_args])
  if not count:
    sys.stderr.write('\nError: One of the following options must be provided: ' + ', '.join([ '-' + o for o in required_args ]) + '\n')
    sys.stderr.write('(Consult the help page for more information: ' + prog + ' -help)\n\n')
    sys.stderr.flush()
    sys.exit(1)

def execute():
  from mrtrix3 import MRtrixError
  from mrtrix3 import algorithm, app, image, path, run, fsl
  if app.ARGS.tumour:
    from tractfinder import virtue

  check_from_required(app.ARGS, ['transform', 'struct'], prog=app.EXEC_NAME)

  ## What steps will we need to do?
  make_brain_mask = False
  if (app.ARGS.tumour or (not app.ARGS.transform and not app.ARGS.premasked)):
    # We've established we *need* a mask. Do we need to *make* one?
    if not app.ARGS.brain_mask:
      make_brain_mask = True
      if not app.ARGS.struct:
    ## TODO: if -struct and -premasked, allow that? then can threshold premasked ? but kinda dodgy, can't be sure what values will be outside the brain
        raise MRtrixError('A brain mask is required for either registration (-transform option not provided) or tumour deformation modelling (-tumour option provided). ' +
                          'Either provide one with -brain_mask or provide a structural image with -struct from which a mask can be generated.')

  atlas_paths = []
  output_paths = []

  ## Check and parse argument inputs
  if len(app.ARGS.arg_pairs) % 2:
    raise MRtrixError('command expects pairs of input tract atlas and output map images to be provided.')
  elif len(app.ARGS.arg_pairs) == 2:
    # Check if directories have been provided
    source, dest = app.ARGS.arg_pairs
    if os.path.isdir(source):
      app.debug('Atlas input is directory')
      make_dir(dest)
      for p in path.all_in_dir(source, dir_path=True):
        try:
          h = image.Header(p)
          if h.is_sh(): atlas_paths.append(p)
          else: app.console('Skipping non-SH input file \'' + h.name() + '\'')
        except MRtrixError: pass
      output_paths = [os.path.join(dest, os.path.splitext(os.path.basename(in_path))[0] + app.ARGS.suffix + os.path.splitext(os.path.basename(in_path))[1]) for in_path in atlas_paths]
      for i, p in reversed(list(enumerate(copy.copy(output_paths)))):
        try: app.check_output_path(p)
        except MRtrixError:
          app.console('Skipping output file \'' + p + '\' (use -force to override)') # Should this be warn()?
          atlas_paths.pop(i)
          output_paths.pop(i)
        finally:
          if not (atlas_paths and output_paths):
            raise MRtrixError('No new outputs to create (use -force to overwrite contents of output directory) \'' + dest + '\'')
      app.debug(f'Creating {len(output_paths)} new files')
    else:
      app.check_output_path(dest)
      atlas_paths, output_paths = [source], [dest]
  else:
    # Arbitrary number of atlas / output pairs
    atlas_paths  = app.ARGS.arg_pairs[::2]
    output_paths = app.ARGS.arg_pairs[1::2]
    for p in output_paths:
      app.check_output_path(p)

  ## Set up filenames and command strings
  bet_cmd = fsl.exe_name('bet')
  flirt_cmd = fsl.exe_name('flirt')
  fsl_suffix = fsl.suffix()

  mask_image_reg = 'brain_mask_reg.mif'
  mask_image_def = 'brain_mask_def.mif'
  tumour_mask = 'tumour_mask.mif'
  def_field_image = 'deformation_field.mif'
  struct_image = 'struct.nii.gz'
  bet_image = 'bet' + fsl_suffix

  app.make_scratch_dir()
  app.goto_scratch_dir()

  # Take strides from template (=atlas space) image, or brain mask, or default to 1,2,3
  strides = ( image.Header(path.from_user(app.ARGS.struct[0], False)).strides()
              if app.ARGS.struct else [1,2,3] )
  strides = ','.join(str(s) for s in strides)

  if app.ARGS.struct:
    run.command(f'mrconvert -strides {strides} '
              + f'{path.from_user(app.ARGS.struct[1])} {struct_image}', show=False)

  ## Brain mask: will be needed for either registration or deformation modelling.
  # Do we need to make one?
  if make_brain_mask:
    if app.ARGS.premasked:
      app.warn('Relying on a pre-masked structural image to produce a brain mask for tumour deformation is risky')
      run.command(f'mrthreshold {path.from_user(app.ARGS.struct[1])} -abs 0 -comparison gt - | '
                + f'mrgrid - regrid {mask_image_def} -strides {strides} -vox 1 -interp nearest -datatype bit', show=False)
      app.debug(f'{mask_image_def} created from struct image with strides {strides}')
    else:
      # BET madness ensues
      app.console('No brain mask provided, attempting to generate robust mask')
      ## Try can create a decent brain mask
      # Start with the FOD amplitude image, fill holes
      run.command('mrconvert -coord 3 0 ' + path.from_user(app.ARGS.input)
                   + ' - |  mrthreshold - -abs 0 -comparison gt fod_mask.nii.gz', show=False)
      run.command('fslmaths fod_mask.nii.gz -fillh fod_mask.nii.gz', show=False)
      # Smooth edges and regrid to structural space
      run.command('mrfilter fod_mask.nii.gz smooth -extent 5 - | '
               +  'mrthreshold - -abs 0.5 - | '
               + f'mrgrid - regrid fod_mask_smooth_regrid.mif '
               + f'-template {struct_image} -interp nearest -strides {strides}', show=False)
      # Dilate and use to roughly crop structural image. This is so that bet
      # has a better change of a clean segmentation without a bunch of neck etc.
      run.command('maskfilter fod_mask_smooth_regrid.mif dilate -npass 5 - | '
               + f'mrcalc - {struct_image} -mult struct_rough_masked.nii.gz', show=False)
      # Brain masking using bet
      run.command(f'{bet_cmd} struct_rough_masked.nii.gz {bet_image} -r 100 -m ', show=False)
      bet_image = fsl.find_image(bet_image)
      # If we also need this brain mask for tumour deformation down the line,
      # convert it now to the correct grid
      if app.ARGS.tumour:
        run.command(f'mrgrid bet_mask{fsl_suffix} regrid {mask_image_def} -vox 1 -interp nearest -datatype bit', show=False)

  ## Registration
  if app.ARGS.transform:
    shutil.copy(path.from_user(app.ARGS.transform, False), 'transform.txt')

  else:
    if app.ARGS.premasked:
      run.command(f'mrconvert -strides {strides} '
                + f'{path.from_user(app.ARGS.struct[1])} {bet_image}', show=False)
    elif app.ARGS.brain_mask:
      run.command(f'mrgrid {path.from_user(app.ARGS.brain_mask)} regrid {mask_image_reg} '
                + f'-datatype bit -interp nearest -strides {strides} '
                + f'-template {struct_image}', show=False)
      run.command(f'mrcalc {mask_image_reg} {struct_image} -mult {bet_image}', show=False)

    # Actually run registrtion
    app.console(f'Running FLIRT registration with {DOF} degrees of freedom')
    run.command(f'{flirt_cmd} -in {path.from_user(app.ARGS.struct[0])} '
              + f'-ref {bet_image} '
              + f'-dof {DOF} -omat transform_flirt.txt')
    run.command(f'transformconvert transform_flirt.txt {path.from_user(app.ARGS.struct[0])} {bet_image} '
               + 'flirt_import transform.txt -quiet', show=False)

  # Finish masking / registration branching

  ## Tumour deformation modelling
  if app.ARGS.tumour:
    app.console('Computing tumour deformation field')
    if app.ARGS.brain_mask:
      run.command(f'mrgrid {path.from_user(app.ARGS.brain_mask)} regrid {mask_image_def} '
                 + '-vox 1 -interp nearest -datatype bit', show=False)
    # Match tumour mask to brain mask grid
    run.command(f'mrgrid {path.from_user(app.ARGS.tumour)} regrid {tumour_mask} '
              + f'-template {mask_image_def}', show=False)

    virtue.entry_point(tumour_mask, mask_image_def, def_field_image)

  ## Cycle through all the atlases
  i, n = 1, len(atlas_paths)
  progress = app.ProgressBar(f'Mapping atlas {i} of {n} to subject')

  for atlas_path, output_path in zip(atlas_paths, output_paths):
    progress.increment(f'Mapping atlas {i} of {n} to subject')

    # Transform atlas
    transf_command_string = (f'mrtransform {path.from_user(atlas_path)} '
                             +'-linear transform.txt -reorient_fod yes ')
    if app.ARGS.tumour:
        # Regridding needs to happen separately, since the mrtransform -template
        # option is applied to the warp field. We'll split the pipe to allow progress increment
        transf_command_string += f'-warp {def_field_image} - '
        tmp_file = run.command(transf_command_string, show=False).stdout
        progress.increment()
        run.command(f'mrgrid {tmp_file} regrid -template {path.from_user(app.ARGS.input)} '
                    + path.to_scratch(f'atlas_{i}.mif'), show=False)

    else:
        transf_command_string += (f'-template {path.from_user(app.ARGS.input)} '
                                + path.to_scratch(f'atlas_{i}.mif'))
        run.command(transf_command_string, show=False)

    progress.increment()

    # Compute inner product
    ip_command_string = (f'mrcalc atlas_{i}.mif {path.from_user(app.ARGS.input)} -mult - | '
                         +'mrmath - sum -axis 3 ')
    if app.ARGS.template:
      app.console(f'Regridding output to match template image "{app.ARGS.template}"')
      ip_command_string += f'- | mrgrid - regrid -template {path.from_user(app.ARGS.template)} '
    if app.ARGS.binary:
      app.console(f'Binarising output with threshold {app.ARGS.binary}')
      ip_command_string += f'- | mrthreshold - -abs {app.ARGS.binary} '
    # Finally append the output file to command
    ip_command_string += path.from_user(output_path)
    run.command(ip_command_string, show=False, force=app.FORCE_OVERWRITE)
    i += 1

  progress.done()

# Execute the script
import mrtrix3, tractfinder
mrtrix3.execute() #pylint: disable=no-member
